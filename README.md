# learn_network
## 0.个人说明
```text
原文地址：https://time.geekbang.org/column/article/7581

个人声明：
优秀的人帮我们总结了精华，而我之所以会写下来，一方面能加深我对知识的理解，另一方面也能够让我散发性思维思考。
此文不会用于商业用途，只是用于自我知识的积累。
```

## 1.为什么要学习网络协议
《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。
人类没办法沟通，达不成“协议”，通天塔的计划就失败了。

但是千年以后，出现了一种“程序猿”的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打造着互联网世界通天塔。
如今的世界，正因为互联网，才连接在一起。

当“Hello world!”从显示器上打印出来的时候，你是否还记得激动的心情？
```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!")
    }
}
```
如果你是程序员，一定看的懂上面这一段代码。这是每个程序员向计算机世界说“你好，世界！”的方式。
但是，你一定不知道，这段代码文字也是一种协议，是人类与计算机沟通的协议，只有通过这种协议，计算机才知道我们想让它干什么。


当然，这种协议还是更接近人类语言，机器不能直接读懂，需要进行翻译，翻译的工作需要交给编译器（compile）。
编译器过程如下：
![编译器编译过程](static/images/01/编译器编译过程.png)
计算机语言作为程序员控制一台计算机工作的协议，具备了三要素（即，**协议三要素**）：
* 语法，就是一段内容要符合一定规则和格式。比如，括号成对，结束要使用分号等
* 语义，就是这一段内容要表达的意义。比如，数字减去数字是有意义的，数字减去文本就没有意义。
* 顺序，就是先做什么，后做什么。比如，你可以先加上某个数值，在减去某个数值。


学会了计算机语言，你就能够教一台计算机完成你的工作了。

但是，想要打造互联网的通天塔，只教给一台计算机做什么是不够的，你需要学会教很多机器做什么。这时就需要网络协议。
只有通过网络协议，才能使很多机器互相协作、共同完成一件事。


网络协议是什么样子，这么神奇？举例说明：  
当你想买一个商品，常规的做法就是打开浏览器，输入购买网站的地址，浏览器会返回给你一个缤纷多彩的页面。  

那你有没有想过，浏览器是如何做到这件事情的？  
它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自HTTP协议的东西。例如：  
```
HTTP/1.1 200 ok
Date: Tue,27 Mar 2018 16:50:26 GMT
Content-Type: text/html;charset=UTF-8
Content-Language: zh-CN

<!DOCTYPE html>
<html>
<head>
<base href="https://pages.kaola.com/">
<meta charset="utf-8"><title>网易考拉3周年主会场</title>
```
它是否符合协议三要素呢？我们来看一下：  
首先，符合语法，也就是说，只有按照上面那个格式来，浏览器才认。比如，先是状态，后是首部，其次是内容。  
其次，符合语义，就是按照约定的意思来。比如，状态200表示网页成功返回。  
然后，符合顺序，你一点浏览器，就发出一个HTTP请求，然后才有上面那一串HTTP返回的东西。  
最后，浏览器按照协议商定好的将一个五彩缤纷的页面展现给你。  


我们常用的网络协议有哪些？我们可以通过“双十一”案例来分析一下：  
你先在浏览器中输入“https//www.kaola.com”这个URL，浏览器只知道名字是“www.kaola.com”，但是不知道具体地址，
所以不知道应该如何访问。于是，它打开地址簿去查找。可以使用一般的地址簿去查找，也可以使用更加精准的地址簿查找协议HTTPDNS。

无论使用哪种方法查找地址簿，最终都会得到一个地址：106.114.138.24.这个就是IP地址，是互联网的门牌号。

知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览器，往往会使用HTTP协议；但是对于购物请求，往往需要进行加密传输，
因而会使用HTTPS协议。无论什么协议，里面都要写明“你买什么和要买多少”。  
应用层封装包：  
![应用层封装包](static/images/01/应用层封装包.png)

DNS、HTTP、HTTPS所在的层我们称为应用层。经过应用层的封装后，浏览器会将应用层的包交给下一层去完成，通过Socket编程来实现。
下一层是传输层，传输层有两种协议：一种是无连接的UDP，另一种是面向连接的协议TCP。对于支付来说，往往使用TCP。
所谓的面向连接协议就是，TCP会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。

TCP协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。  
传输层封装包：  
![传输层封装包](static/images/01/传输层封装包.png)

传输层封装完后，浏览器会将包交给操作系统的网络层。网络层的协议是IP协议。
在IP协议里面会有 源IP地址（即浏览器所在机器的IP地址） 和 目标IP地址（即，电商网站所在服务器IP地址）。  
网络层封装包：  
![网络层封装包](static/images/01/网络层封装包.png)

操作系统知道了目标IP地址，就开始想如何通过这个门牌号找到目标机器。操作系统会判断，这个目标IP地址是本地人，还是外地人。
如果是本地人，从门牌号就能看出来，但是显然电商的网站不在本地，而在遥远的地方。  

操作系统要知道离开本地去远方。虽然不知道远方在何处，但可以类比一下：如果去国外要去海关，去外地就要去网关。
而操作系统启动的时候，就会被DHCP协议配置IP地址，以及默认网关IP地址192.168.1.1。

操作系统如何将IP地址转发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是192.168.1.1啊？网关会回答它，我就是，
我的本地地址在村东头。这个本地地址就是MAC地址，而那一声大吼就是ARP协议。 于是，操作系统将IP包交给了下一层，也就是MAC层。
网卡再将包发出去，由于这个包里面是由MAC地址的，因此它能够到达网关。  
数据链路层封包:  
![数据链路层封包](static/images/01/数据链路层封包.png)

网关收到包后，会根据自己的地址簿，判断下一步该怎么走。网关往往是一个路由器，到某个地址怎么走，这个叫路由表。  
路由器有点像玄奘西行路上通过的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地地址MAC通信。
一旦跨越城关，就需要拿出IP头来，里面写着贫僧从东土大唐（源IP地址）而来，欲往西天拜佛求经（目标IP地址），路过宝地，借宿一晚，
明日启程，请问接下来该怎么走啊？  
路由表选址：  
![路由表选址](static/images/01/路由表选址.png)

城关往往知道这些“地址簿”的，因为城关和临近的城关会经常沟通。到哪里应该怎么走，这种沟通的协议称为路由协议，常用OSPF和GBP。  

城关和城关之间是一个国家，当网络包知道下一步去哪个城关后，还是要使用国家内部的MAC地址，通过下一个城关的MAC地址，找到下一个城关，
然后再问下一步的路该怎么走，一直走出最后一个城关。

最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标IP啊？目标服务器就会回复一个MAC地址。
网络包过关后，通过这个MAC地址就能找到目标服务器。

目标服务器发现MAC地址对上了，取下MAC头来，发送给操作系统的网络层。网络层发现IP地址也对上了，就取下IP头。
IP头会写上上一层封装的是TCP协议，然后将其交给传输层，即TCP层。 在这一层里，对于收到的每一个包，都会有一个回复的包说明收到了。
这个回复的包绝非这次下单请求的结果，例如：你购物是否成功，扣了多少钱，而仅仅是TCP层的一个说明，即收到包的回复。
当然这个回复会沿着刚才来的方向走回去，报个平安。如果过了一段时间还没到，发送端的TCP层会重新发送这个包，还是上面的过程，
直到有一天收到平安到达的回复。这个重试绝非你的浏览器重新将下单这个动作重复异常。对于浏览器来讲，就发送了一次下单请求，
TCP层会不断自己闷头重试，除非TCP这一层出了问题，例如断连，才轮到浏览器的应用层重新发送下单请求。

当网络包平安到达TCP层之后，TCP头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，
假设是一个Tomcat，然后就将包发送给电商网站。电商网站的进程得到HTTP请求的内容，知道了要买的东西，买多少。
往往一个电商网站最初接待请求的这个tomcat只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。
例如：这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少；要告诉管理库存的进程，库存要减多少；
告诉支付的进程，应该付多少钱，等等。

如何告诉相关进程呢？往往通过RPC调用，即远程过程调用的是方式来实现。远程过程调用就是当告诉管理订单进程的时候，
接待员不用关系中间的网络互连问题，会由RPC框架统一处理。RPC框架有很多种，有基于HTTP协议放在HTTP报文里面的，
有直接封装在TCP报文里面的。

当接待员发现相应的部门都处理完毕，就回复一个HTTPS包，告知下单成功。这个HTTPS的包，会向来的时候一样，经过千难万险到达到你的个人电脑，
最终进入浏览器，显示支付成功。


## 2.网络分层的含义是什么？
当你听到二层设备、三层设备、四层LB和七层LB中层的时候，是否有点一头雾水，不知道这些所谓的层，对应的各种协议具体要做什么“工作”？  

1.这四个问题你真的懂了吗？
教科书或老师往往会打一个十分不恰当的比喻：为什么网络要分层啊？因为不同层次之间有不同的沟通方式，这个叫作协议。
教科书会列出每层所包含的协议，然后开始逐层地去将这些协议。但是这些协议之间的关系呢？却很少有教科书会讲。

比如：一家公司也是分“层次”的，分总经理、经理、组长、员工。总经理之间有他们的沟通方式，经理和经理也有沟通方式，同理组长和员工。
那么第一个问题，请问经理在握手的时候，员工在干什么？

很多人听过TCP建立连接的三次握手协议，也把它当作知识点来背。同理问你，TCP在三次握手的时候，IP层和MAC层对应有什么操作？

在学习到三层的时候会提到，IP协议里面包含目标地址和源地址。第三层还会学习路由协议。路由就像中转站，我们从原始地址A到目标地址D，
要经过两个中转站 A -> B -> C -> D，是通过路由转发的。  
那么第二个问题，A知道自己的下一个中转站是B，那从A发出的包，应该把B的IP地址放在哪里呢？B知道自己的下一个中转站是C，从B发出的包，
应该把C的IP地址放在哪里呢？如果放在IP协议中的目标地址，那包到了中转站，怎么知道最终的目的地址是D呢？

你一定听过二层设备、三层设备。二层设备处理的通常是MAC层的东西。那我发送一个HTTP的包，是在第七层工作的，那是不是不需要经过二层设备？
或者即便经过了，二层设备不处理呢？或者换个问法，二层设备处理的包，有没有HTTP层的内容呢？

最终，考虑一个综合问题。从你的电脑，通过SSH登录到公有云里面，都需要经历哪些过程？或者你打开一个网站，都徐哟奥经理哪些过程？

2.网络为什么分层？
理解计算机中的概念，一个很好的角度是，想象网络包就是一段Buffer，或者一块内存，是有格式的。同时，想象自己是一个处理网络包的程序，
而且这个程序可以跑在电脑上，可以跑在服务器上，可以跑在交换机，可以跑在路由器上。你想象自己有很多的网口，从某个口拿进一个网络包，
用自己的程序处理一下，再从另一个网口发送出去。

当然，网络包的格式很复杂，这个程序也很复杂。复杂的程序都需要分层，这是程序设计的要求。
比如，复杂的电商还会分数据库层、缓存层、Compose层、Controller层和接入层，每一层专注做本层的事情。

3.程序是如何工作的？
![程序工作流程](static/images/02/程序工作流程.jpg)

首先，把你想象成一个程序：  
1. 当一个网络包从一个网口经过的时候，你看到了它，首先判断一下要不要拿进来，处理一下。
有的网口配置了混杂模式，凡是经过的网络包，都会全部拿进来。  
2. 拿进来以后，就要交给一段程序处理。于是你调用process_layer2(buffer)函数(此时是假函数)，
从Buffer中摘掉二层的头，看一看，应该根据里面的内容做什么操作。
3. 假设你发现这个包的MAC地址和你的相符，那说明它是发送给你的，于是需要调用process_layer3(buffer)函数（
这个时候，Buffer里面已经没有了二层的头了，因为在上一个函数的处理过程中摘掉了。），
从Buffer中摘掉三层的头，看一看到底是发送给自己的，还是希望自己转发出去。  
4. 如何进行判断呢？ 如果IP地址不是自己的，那就应该转发出去；如果IP地址是自己的，那就是发送给自己的。
5. 根据IP头里面的表示，拿掉三层的头，进行下一层处理，到底是发送给process_tcp(buffer)呢，还是调用process_udp(buffer)呢？
6. 假设，这个地址是TCP的，则会调用process_tcp(buffer)函数（此时，Buffer里没有第三层的头），查看四层的头，
看这是一个发起，还是应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。
7. 如果是发起或者是应答，接下来就要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。
8. 上层交给谁呢？是http_http(buffer)函数吗？不是的，如果你是一个网络包处理程序，你不需要有http_http(buffer)，而是应该交给应用去处理。
9. 交给哪个应用呢？在四层的头里面有端口号，不同的应用监听使用不同的端口号。如果发现应用在监听那个端口，那你发给浏览器就行了。
至于，浏览器怎么处理，和你没有关系了。
10. 浏览器自然是解析HTML，显示出页面来。电脑主人很开心，就点击了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起一个HTTP请求了，
于是使用端口号，将请求发给了你。
11. 你应该调用send_tcp(buffer).不用说，Buffer里面就是HTTP请求的内容。这个函数里面加一个TCP头，记录下源端口号。
浏览器会给你目标端口号，一般为80端口。
12. 然后调用send_layer3(buffer)。Buffer里面已经有了HTTP头和内容，以及TCP头。在这个函数里面加一个IP头，记录下源IP的地址和目标IP的地址。
13. 然后调用send_layer2(buffer)。Buffer里面已经有了HTTP头和内容、TCP头，以及IP的头。
这个函数要加一下MAC地址，得到的就是本机的MAC地址和目标MAC地址。
不过这个还要看当前知不知道，知道直接加上；不知道的话，就需要通过一定的协议处理过程，找到MAC地址。反正要填写一个，不能空着。
14. 万事具备，只要Buffer里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了。

4.揭秘层与层之间的关系  
知道了上面的过程后，我们再来看一下原来困惑的问题。

首先是分层比喻。所有不能表示出层层封装含义的比喻，都是不恰当的。总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧。
但在网络的世界里不是这样的。正确的应该是，总经理之间沟通的时候，经理将总经理放在自己兜里，然后是组长把经理放在兜里，员工把组长放在兜里，
向套娃娃一样。那员工直接沟通，不带上总经理，就不恰当了。 

现实的情况是，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理补充两句。
但在网络世界里，应该是总经理说一句，经理补充两句，组长补充两句，员工在补充两句。

那TCP在三次握手的时候，IP层和MAC层在做什么？ 当然是TCP发送每一个消息，都会带着IP层和MAC层。
因为，TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。而你只看到TCP三次握手，其实IP和MAC层为此忙活了好久了。

请记住一点：**只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。**

所以，对于TCP协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP层和MAC层，不然是发不出去的。

经常有人会问一个问题，我都知道那台机器的IP地址了，直接发给它消息呗，要MAC地址干啥？这里的关键就是，***没有MAC地址消息是发送不出去的。**
所以如果一个HTTP协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。

所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个HTTP协议的包经过一个二层设备，二层设备收进去的是整个网络包。
这里面的HTTP、TCP、IP、MAC都有。

什么叫二层设备？就是只把MAC头摘下来，看看到底是丢弃、转发，还是自己留着。

什么叫三层设备？就是把MAC头摘下来之后，再把IP头摘下来，看看到底是丢弃、转发，还是自己留着。

5.总结
* 始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去
* 始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，但绝对不可能有上层没下层。


## 3.ifconfig：最熟悉又陌生的命令行
1.你知道怎么查看IP地址吗？  
只要倒腾到电脑的人应该都很容易回答这个问题：在windows上ipconfig，在linux上是ifconfig，在linux上另一种方式是ip addr。  

我们使用ip addr来查看一下IP地址:
```bash
[root@dev ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
      valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 52:54:00:d9:ec:8e brd ff:ff:ff:ff:ff:ff
    inet 192.168.13.208/24 brd 192.168.13.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::84b8:3cff:fee2:d136/64 scope link 
       valid_lft forever preferred_lft forever
```

上面，显示了这台机器上所有的网卡。大部分网卡都只会有一个IP地址，当然这不是必须的。
**IP地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码。**   

如上，输出的结果“192.168.13.208”就是一个IP地址。这个地址被点号分隔为四个部分，每个部分8个bit，所以IP地址总共是32位。
这样产生的IP地址很快就不够用了，因为当初设计IP地址的时候，不知道今天会有这么多的计算机。因为IP地址不够用，于是有了IPv6，
也就是上面的“fe80::84b8:3cff:fee2:d136/64”，这个有128位，现在看是够了，但未来的事情谁知道呢？  

本来，32位的IP地址就不够用，还被分成了5类，现在想想，当时分配地址的时候，太奢侈了。如下:  
![IP五类地址](static/images/03/IP五类地址.jpg)
在网络地址中，在当时涉及的时候，对于A、B、C类主要分为两部分，前面部分是网络号，后面一部分是主机号。 
A、B、C三类地址所能包含的主机数量：
![ABC三类地址主机数量](static/images/03/ABC三类地址主机数量.jpg)

2.无类型域间选路（CIRD）  
这里有个尴尬的事情，那就是C类地址包含的主机数量太少了，只有254个。B类地址能包含的主机梳理又太多了。
于是有了一个折中的方式叫**无类型域间选路，简称CIDR。** 这种方式打破了原来设计的几类地址的做法，**将32位地址的IP地址一分为二，
前面是网络号，后面是主机号。**  

还是观察上面的IP地址信息，你可以看到“192.168.13.208/24”，这个IP地址中有个斜杠，斜杠后面的数字是24。
这种地址表示形式就是CIRD。后面的24的意思是在32位地址中，前24位是网络号，后8位是主机号。
伴随着CIRD的存在，还存在两个地址：
一个是广播地址，192.168.13.255，如果发送这个地址，所有192.168.13.x网络里面的机器都可以收到；
一个是子网掩码，255.255.255.0,。  

**将子网掩码和IP地址进行AND计算，就可以得到网络号。** 
计算方式为：子网掩码前三个255，转换二进制都是1。1和任何数值取值AND，都是原来的数值。因此前面三个数不变，为192.168.13。
后面一个0转换成二进制还是0。0和任何数值取值AND都是0。因此最后一位是0，合起来就是192.168.13.0，这就是网络号。  

3.公有IP地址和私有IP地址
在日常生活中，几乎不用划分A类、B类、C类，所以时间长了，人们就忘记了这个分类，而只记得CIDR。
但是，还有一点需要注意的，那就是公有IP地址和私有IP地址。
![公有地址和私有地址](static/images/03/公有地址和私有地址.jpg)
表格的右列是私有IP地址段，平时我们看到的数据中心、办公室、家里或学校的IP地址，一般都是私有IP地址段。
公有地址有个组织统一分配，你需要去购买。

举例：一个容易犯错的CIDR  
我们来看 16.158.165.91/22 这个CIDR，我们求一下这个网络地址的第一个地址、子网掩码和广播地址。  
首先，22不是8的倍数，先将其变为二进制来看，16.158的部分不动，因为它们占了前16位。还剩余6位。  
其次，中间的165，变成二进制是10100101。所以，这八位中的前6位是网络号,即：16.158.<101001>,而<01>.91是主机号。  
然后，第一个地址是16.158.<101001><00>.1，即16.158.164.1  
然后，子网络掩码是255.255.<111111><00>.0，即255.255.252.0  
然后，广播地址是16.158.<101001><11>.255，即16.158.167.255  

这五类地址中，还有一类D类是组播地址，使用这一类地址，属于某个组织的机器都能收到。
这有点像公司里面的邮件组，发送邮件，加入这个组的人都可以收到。

4.剩余参数说明  
在IP地址后面有个scope，对于eth0这个网卡来讲是global，说明这张网卡是可以对外的，可以接收来自各个地方的包；
对于lo来讲是host，说明这张网卡仅仅可以供本机互相通信。

lo全称lookback，又称为环回接口，往往被分配到127.0.0.1这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。

在IP地址的上一层是“link/ether 52:54:00:d9:ec:8e brd ff:ff:ff:ff:ff:ff”，这个被称为MAC地址，是一个网卡的物理地址，用十六进制，6个byte表示。  

MAC地址是一个很容易“误解”的地址。因为MAC地址号称全局唯一，不会有两个网卡有相同的MAC地址，而且网卡自生产出来，就带着这个地址。
很多人看到就会想，既然这样，整个互联网的通信，全都使用MAC地址好了，只要知道MAC地址，就可以把信息传递过去。
这样当然不行的，**一个网络包要从一个地方传递到另外一个地方，除了要有确定的地址，还需要有定位功能。
而有门牌号属性的IP地址，才是有远程定位功能；MAC地址更像是身份证，是一个全局的唯一的标识。**

解析完MAC地址，我们再来看“<BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000”。  
其中“<BROADCAST,MULTICAST,UP,LOWER_UP>”这个叫net_device flags，即网络设备的状态标识。
UP表示网卡处于启动状态；BROADCAST表示这个网卡有广播地址，可以发送广播包；
MULTICAST表示网卡可以发送多播包；LOWER_UP表示L1是启动的，即网线插着呢。  

其中“mtu 1500”表示以太网最大的默认传输单元。MTU是二层MAC层的概念，MAC层有MAC头，以太网规定MAC头和正文合起来，不允许超过1500个字节。
正文里面有IP头、TCP头、HTTP头，如果放不下，就分片来处理。  

其中“qdisc pfifo_fast”表示队列规则，内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的qdisc(队列规则)把数据包加入队列。
最简单的qdisc是pfifo，它不对进入的数据包进行任何处理，数据包采用先入先出的方式通过队列；pfifo_fast稍微复杂一些，它的队列包含三个波段(band)。
在每个波段里面，使用先进先出规则。

三个波段的优先级也不相同。band 0 的优先级最高，band 2的最低。
如果band 0里面有数据包，系统就不会处理band 1里面的数据包，band 1 和 band 2之间也一样。  

数据包是按照服务类型（Type of Service，TOS）被分配多三个波段(band)里面的。TOS是IP头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。

5.总结
* IP是地址，有定位功能；MAC是身份证，无定位功能
* CIDR可以用来判断是不是本地人
* IP分公有IP和私有IP地址

6.思考
* 你知道net-tools和iproute2的“历史”故事吗？  
net-tools起源于BSD，自2001年起，linux社区已停止对其维护；而iproute2旨在取代net-tools，并提供一些新功能。
net-tools通过procfs(/proc)和ioctl系统调用去访问和改变内核网络配置；而iproute2通过netlink套接字接口与内核通讯。
net-tools中工具的名字比较杂乱；而iproute2则相对整齐和直观。
* 你知道IP地址是怎么来的吗？





































